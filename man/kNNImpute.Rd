% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/kNN.R
\name{kNNImpute}
\alias{kNNImpute}
\title{kNN Impute}
\usage{
kNNImpute(x, k, x.dist = NULL, impute.fn, verbose = TRUE,
  check.scale = TRUE)
}
\arguments{
\item{x}{a \code{matrix} or \code{data.frame} which can be coerced to a matrix
where each row represents a different record}

\item{k}{the number of neighbors to use for imputation}

\item{x.dist}{Optional. A pre-computed distance matrix to be used for kNN}

\item{impute.fn}{The imputation function to run on the length k vector of values for
a missing feature.  Defaults to weighted mean-KNN; see Details.}

\item{verbose}{if \code{TRUE} print status updates}

\item{check.scale}{Logical. If \code{TRUE} compute pairwise variance tests to see if
variables are on a common scale. Bonferroni correction applied.}
}
\description{
Imputation using k-nearest neighbors.
For each record, identify missinng features.  For each missing feature
find the k nearest neighbors which have that feature.  Impute the missing
value using the imputation function on the k-length vector of values
found from the neighbors.
}
\details{
The default \code{impute.fn} weighs the $k$ values by their respective distances.
  The result is the weighted mean of the values of the nearest neighbors
  with weights based on their distance.  It is implemented as follows:
\preformatted{impute.fn = function(values, distances, k) {
  ranks = order(distances)
  smallest.distances = distances[ranks][1:k]
  knn.values = values[ranks][1:k]
  knn.weights = 1 - (smallest.distances / max(distances))
  weighted.mean(knn.values, knn.weights)
}}
Alternatively, a simple mean can be implemented as follows:
\preformatted{impute.fn = function(values, distances, k) {
  ranks = order(distances)
  mean(distances[ranks][1:k])
}}
}
\examples{
x = matrix(rnorm(100),10,10)
  x.missing = x > 1
  x[x.missing] = NA
  kNNImpute(x, 3)
}
\references{
Missing value estimation methods for DNA microarrays.  Troyanskaya et al.
}

